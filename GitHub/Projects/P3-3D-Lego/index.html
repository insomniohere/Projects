<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>BrickForge - Professional 3D LEGO Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }

        #app {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        #ui-panel {
            position: absolute;
            left: 20px;
            top: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            width: 320px;
        }

        #ui-panel.collapsed {
            transform: translateX(-340px);
        }

        #toggle-panel {
            position: absolute;
            left: 20px;
            top: 20px;
            width: 48px;
            height: 48px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s, left 0.3s;
            z-index: 999;
            font-size: 24px;
        }

        #toggle-panel:hover {
            transform: scale(1.1);
        }

        #toggle-panel.panel-open {
            left: 360px;
        }

        h2 {
            font-size: 22px;
            margin-bottom: 16px;
            color: #667eea;
            font-weight: 700;
        }

        h3 {
            font-size: 14px;
            margin: 16px 0 8px 0;
            color: #555;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .section:last-child {
            border-bottom: none;
        }

        .brick-palette {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }

        .brick-item {
            aspect-ratio: 1;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            font-size: 11px;
            text-align: center;
            font-weight: 600;
            color: #555;
            padding: 4px;
        }

        .brick-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            border-color: #667eea;
        }

        .brick-item.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
            margin-bottom: 12px;
        }

        .color-item {
            aspect-ratio: 1;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border: 3px solid transparent;
        }

        .color-item:hover {
            transform: scale(1.15);
        }

        .color-item.selected {
            border-color: #333;
            transform: scale(1.1);
        }

        button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        button.danger {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .toggle-group {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .toggle-btn {
            flex: 1;
            padding: 10px;
            background: #f0f0f0;
            color: #666;
            border-radius: 8px;
            font-size: 12px;
            transition: all 0.2s;
        }

        .toggle-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 12px;
            background: white;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
        }

        .info-box {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.5;
            color: #555;
            margin-bottom: 12px;
        }

        .shortcuts {
            font-size: 11px;
            color: #777;
            line-height: 1.6;
        }

        .shortcuts strong {
            color: #667eea;
            font-weight: 600;
        }

        #selection-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 14px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 1000;
        }

        #selection-info.visible {
            opacity: 1;
        }

        .template-gallery {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .template-item {
            padding: 12px;
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            font-weight: 600;
            border: 2px solid transparent;
        }

        .template-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            border-color: #667eea;
        }

        @keyframes wobble {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-5px) rotate(-2deg); }
            50% { transform: translateY(-2px) rotate(2deg); }
            75% { transform: translateY(-3px) rotate(-1deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            text-align: center;
            color: white;
        }

        .loader-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f0f0f0;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loader">
            <div class="loader-spinner"></div>
            <h2>BrickForge Loading...</h2>
        </div>
    </div>

    <div id="app">
        <div id="canvas-container"></div>

        <div id="toggle-panel" class="panel-open">‚ò∞</div>

        <div id="ui-panel">
            <h2>üß± BrickForge</h2>

            <div class="section">
                <h3>Brick Library</h3>
                <div class="brick-palette" id="brick-palette"></div>
            </div>

            <div class="section">
                <h3>Colors</h3>
                <div class="color-palette" id="color-palette"></div>
            </div>

            <div class="section">
                <h3>Actions</h3>
                <button id="btn-undo">‚Ü∂ Undo (Ctrl+Z)</button>
                <button id="btn-redo">‚Ü∑ Redo (Ctrl+Y)</button>
                <button id="btn-copy">üìã Copy (Ctrl+C)</button>
                <button id="btn-paste">üìã Paste (Ctrl+V)</button>
                <button id="btn-delete" class="secondary">üóëÔ∏è Delete (Del)</button>
            </div>

            <div class="section">
                <h3>View Options</h3>
                <div class="toggle-group">
                    <button class="toggle-btn active" id="toggle-grid">Grid Snap</button>
                    <button class="toggle-btn active" id="toggle-angle">Angle Snap</button>
                </div>
                <label style="font-size: 13px; color: #666; display: block; margin-bottom: 8px;">Baseplate Size</label>
                <select id="baseplate-size">
                    <option value="16">16x16</option>
                    <option value="32" selected>32x32</option>
                    <option value="48">48x48</option>
                    <option value="64">64x64</option>
                </select>
            </div>

            <div class="section">
                <h3>Templates</h3>
                <div class="template-gallery" id="template-gallery"></div>
            </div>

            <div class="section">
                <h3>Project</h3>
                <button id="btn-save">üíæ Save Project</button>
                <button id="btn-load">üìÇ Load Project</button>
                <button id="btn-export">üì§ Export JSON</button>
                <button id="btn-import">üì• Import JSON</button>
                <button id="btn-clear" class="danger">üóëÔ∏è Clear Scene</button>
            </div>

            <div class="section">
                <h3>Controls</h3>
                <div class="shortcuts">
                    <strong>Click:</strong> Place brick<br>
                    <strong>Drag:</strong> Orbit camera<br>
                    <strong>Q/E:</strong> Rotate brick<br>
                    <strong>Shift+Drag:</strong> Multi-select<br>
                    <strong>Scroll:</strong> Zoom<br>
                    <strong>Del:</strong> Delete selected
                </div>
            </div>
        </div>

        <div id="selection-info"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ===== CONFIGURATION =====
        const STUD_HEIGHT = 0.17;
        const PLATE_HEIGHT = 0.32;
        const BRICK_HEIGHT = 0.96;
        const STUD_UNIT = 0.8;

        const COLORS = {
            'Bright Red': 0xC91A09,
            'Bright Blue': 0x0055BF,
            'Bright Yellow': 0xF2CD37,
            'Dark Green': 0x237841,
            'Bright Orange': 0xFE8A18,
            'White': 0xF2F3F2,
            'Black': 0x05131D,
            'Dark Grey': 0x6C6E68,
            'Light Grey': 0x9BA19D,
            'Tan': 0xE4CD9E,
            'Dark Tan': 0x958A73,
            'Brown': 0x583927,
            'Bright Green': 0x4B9F4A,
            'Lime': 0xD9E04A,
            'Dark Orange': 0xA95500,
            'Medium Blue': 0x5A93DB,
            'Light Blue': 0xB4D2E3,
            'Bright Purple': 0xE4ADC8,
            'Dark Purple': 0x81007B,
            'Pink': 0xFC97AC,
            'Medium Lavender': 0xA5A5CB,
            'Sand Blue': 0x6074A1,
            'Sand Green': 0xA0BCAC,
            'Reddish Brown': 0x582A12
        };

        const BRICK_TYPES = [
            { name: '1x1', w: 1, h: 1, type: 'brick' },
            { name: '1x2', w: 1, h: 2, type: 'brick' },
            { name: '1x3', w: 1, h: 3, type: 'brick' },
            { name: '1x4', w: 1, h: 4, type: 'brick' },
            { name: '1x6', w: 1, h: 6, type: 'brick' },
            { name: '1x8', w: 1, h: 8, type: 'brick' },
            { name: '2x2', w: 2, h: 2, type: 'brick' },
            { name: '2x3', w: 2, h: 3, type: 'brick' },
            { name: '2x4', w: 2, h: 4, type: 'brick' },
            { name: '2x6', w: 2, h: 6, type: 'brick' },
            { name: '2x8', w: 2, h: 8, type: 'brick' },
            { name: '2x10', w: 2, h: 10, type: 'brick' },
            { name: '4x4', w: 4, h: 4, type: 'brick' },
            { name: '6x6', w: 6, h: 6, type: 'brick' },
            { name: '8x8', w: 8, h: 8, type: 'brick' },
            { name: '1x1 Plate', w: 1, h: 1, type: 'plate' },
            { name: '1x2 Plate', w: 1, h: 2, type: 'plate' },
            { name: '1x4 Plate', w: 1, h: 4, type: 'plate' },
            { name: '2x2 Plate', w: 2, h: 2, type: 'plate' },
            { name: '2x4 Plate', w: 2, h: 4, type: 'plate' },
            { name: '4x4 Plate', w: 4, h: 4, type: 'plate' },
            { name: '6x6 Plate', w: 6, h: 6, type: 'plate' },
            { name: '8x8 Plate', w: 8, h: 8, type: 'plate' },
            { name: '1x2 Tile', w: 1, h: 2, type: 'tile' },
            { name: '2x2 Tile', w: 2, h: 2, type: 'tile' },
            { name: '2x4 Tile', w: 2, h: 4, type: 'tile' },
            { name: '2x2 Slope', w: 2, h: 2, type: 'slope' },
            { name: '2x3 Slope', w: 2, h: 3, type: 'slope' },
            { name: '2x4 Slope', w: 2, h: 4, type: 'slope' }
        ];

        const TEMPLATES = {
            'Car': [
                { type: 'plate', w: 2, h: 6, x: 0, y: 0, z: 2, color: 'Bright Red', rotation: 0 },
                { type: 'brick', w: 2, h: 4, x: 0, y: 1, z: 1, color: 'Bright Red', rotation: 0 },
                { type: 'plate', w: 2, h: 2, x: 0, y: 2, z: 1, color: 'White', rotation: 0 },
                { type: 'brick', w: 1, h: 2, x: -0.5, y: 0, z: 3, color: 'Black', rotation: 0 },
                { type: 'brick', w: 1, h: 2, x: 0.5, y: 0, z: 3, color: 'Black', rotation: 0 }
            ],
            'Castle': [
                { type: 'brick', w: 8, h: 8, x: 0, y: 0, z: 0, color: 'Dark Grey', rotation: 0 },
                { type: 'brick', w: 2, h: 2, x: -2.5, y: 1, z: -2.5, color: 'Dark Grey', rotation: 0 },
                { type: 'brick', w: 2, h: 2, x: 2.5, y: 1, z: -2.5, color: 'Dark Grey', rotation: 0 },
                { type: 'brick', w: 2, h: 2, x: -2.5, y: 1, z: 2.5, color: 'Dark Grey', rotation: 0 },
                { type: 'brick', w: 2, h: 2, x: 2.5, y: 1, z: 2.5, color: 'Dark Grey', rotation: 0 },
                { type: 'brick', w: 2, h: 2, x: -2.5, y: 2, z: -2.5, color: 'Dark Grey', rotation: 0 },
                { type: 'brick', w: 2, h: 2, x: 2.5, y: 2, z: -2.5, color: 'Dark Grey', rotation: 0 },
                { type: 'brick', w: 2, h: 2, x: -2.5, y: 2, z: 2.5, color: 'Dark Grey', rotation: 0 },
                { type: 'brick', w: 2, h: 2, x: 2.5, y: 2, z: 2.5, color: 'Dark Grey', rotation: 0 }
            ],
            'Spaceship': [
                { type: 'brick', w: 2, h: 6, x: 0, y: 0, z: 0, color: 'Light Grey', rotation: 0 },
                { type: 'slope', w: 2, h: 2, x: 0, y: 0, z: -3, color: 'Light Grey', rotation: 0 },
                { type: 'plate', w: 4, h: 2, x: 0, y: 0.5, z: 1, color: 'Medium Blue', rotation: 0 },
                { type: 'brick', w: 1, h: 2, x: -1.5, y: 0, z: 0, color: 'Bright Red', rotation: 0 },
                { type: 'brick', w: 1, h: 2, x: 1.5, y: 0, z: 0, color: 'Bright Red', rotation: 0 },
                { type: 'plate', w: 2, h: 2, x: 0, y: 1, z: 0, color: 'White', rotation: 0 }
            ],
            'Robot': [
                { type: 'brick', w: 2, h: 2, x: 0, y: 2, z: 0, color: 'Bright Yellow', rotation: 0 },
                { type: 'brick', w: 2, h: 3, x: 0, y: 1, z: 0, color: 'Bright Blue', rotation: 0 },
                { type: 'brick', w: 1, h: 2, x: -1, y: 1, z: 0, color: 'Bright Blue', rotation: 0 },
                { type: 'brick', w: 1, h: 2, x: 1, y: 1, z: 0, color: 'Bright Blue', rotation: 0 },
                { type: 'brick', w: 1, h: 1, x: -0.5, y: 0, z: 0, color: 'Dark Grey', rotation: 0 },
                { type: 'brick', w: 1, h: 1, x: 0.5, y: 0, z: 0, color: 'Dark Grey', rotation: 0 },
                { type: 'plate', w: 1, h: 1, x: -0.5, y: 2, z: 0, color: 'White', rotation: 0 },
                { type: 'plate', w: 1, h: 1, x: 0.5, y: 2, z: 0, color: 'White', rotation: 0 }
            ],
            'House': [
                { type: 'brick', w: 6, h: 8, x: 0, y: 0, z: 0, color: 'Tan', rotation: 0 },
                { type: 'brick', w: 2, h: 2, x: 0, y: 0, z: -2, color: 'Brown', rotation: 0 },
                { type: 'slope', w: 2, h: 6, x: 0, y: 1, z: -2, color: 'Reddish Brown', rotation: 0 },
                { type: 'slope', w: 2, h: 6, x: 0, y: 1, z: 2, color: 'Reddish Brown', rotation: 2 },
                { type: 'plate', w: 2, h: 2, x: -1.5, y: 0, z: 0, color: 'Light Blue', rotation: 0 },
                { type: 'plate', w: 2, h: 2, x: 1.5, y: 0, z: 0, color: 'Light Blue', rotation: 0 }
            ],
            'Tree': [
                { type: 'brick', w: 2, h: 2, x: 0, y: 0, z: 0, color: 'Brown', rotation: 0 },
                { type: 'brick', w: 2, h: 2, x: 0, y: 1, z: 0, color: 'Brown', rotation: 0 },
                { type: 'brick', w: 4, h: 4, x: 0, y: 2, z: 0, color: 'Dark Green', rotation: 0 },
                { type: 'brick', w: 4, h: 4, x: 0, y: 3, z: 0, color: 'Dark Green', rotation: 0 },
                { type: 'brick', w: 2, h: 2, x: 0, y: 4, z: 0, color: 'Bright Green', rotation: 0 }
            ]
        };

        // ===== STATE =====
        let scene, camera, renderer, controls;
        let baseplate;
        let currentBrickType = BRICK_TYPES[0];
        let currentColor = Object.keys(COLORS)[0];
        let currentRotation = 0;
        let ghostBrick = null;
        let placedBricks = [];
        let selectedBricks = [];
        let undoStack = [];
        let redoStack = [];
        let gridSnap = true;
        let angleSnap = true;
        let baseplateSize = 32;
        let isSelecting = false;
        let selectionStart = null;
        let selectionBox = null;
        let copiedBricks = [];
        let audioContext;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // ===== INITIALIZATION =====
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 150);

            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 25, 20);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 100;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(30, 50, 20);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 100;
            scene.add(dirLight);

            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-20, 20, -20);
            scene.add(fillLight);

            // Baseplate
            createBaseplate();

            // Ghost brick
            createGhostBrick();

            // Audio context
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log('Audio not supported');
            }

            // UI
            initUI();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onClick);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('contextmenu', onContextMenu);
            document.addEventListener('keydown', onKeyDown);

            // Touch support
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });

            // Load saved project
            loadFromLocalStorage();

            // Animation loop
            animate();

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 500);
        }

        // ===== BRICK CREATION =====
        function createBrickGeometry(width, depth, brickType) {
            const group = new THREE.Group();

            const brickWidth = width * STUD_UNIT;
            const brickDepth = depth * STUD_UNIT;
            let brickHeight;

            if (brickType === 'plate') {
                brickHeight = PLATE_HEIGHT;
            } else {
                brickHeight = BRICK_HEIGHT;
            }

            // Main body
            const bodyGeometry = new THREE.BoxGeometry(brickWidth, brickHeight, brickDepth);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                roughness: 0.4,
                metalness: 0.1
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);

            // Studs (not for tiles)
            if (brickType !== 'tile') {
                const studGeometry = new THREE.CylinderGeometry(0.24, 0.24, STUD_HEIGHT, 16);
                const studMaterial = new THREE.MeshStandardMaterial({
                    roughness: 0.2,
                    metalness: 0.3,
                    clearcoat: 0.3,
                    clearcoatRoughness: 0.2
                });

                for (let x = 0; x < width; x++) {
                    for (let z = 0; z < depth; z++) {
                        const stud = new THREE.Mesh(studGeometry, studMaterial);
                        stud.position.set(
                            (x - width / 2 + 0.5) * STUD_UNIT,
                            brickHeight / 2 + STUD_HEIGHT / 2,
                            (z - depth / 2 + 0.5) * STUD_UNIT
                        );
                        stud.castShadow = true;
                        group.add(stud);
                    }
                }
            }

            // Slope
            if (brickType === 'slope') {
                const slopeGeometry = new THREE.BoxGeometry(brickWidth, brickHeight, brickDepth);
                const slope = new THREE.Mesh(slopeGeometry, bodyMaterial);
                slope.rotation.x = -Math.PI / 6;
                slope.position.y = brickHeight / 3;
                slope.position.z = -brickDepth / 4;
                slope.castShadow = true;
                slope.receiveShadow = true;
                group.add(slope);
                body.visible = false;
            }

            return group;
        }

        function createGhostBrick() {
            if (ghostBrick) {
                scene.remove(ghostBrick);
            }

            ghostBrick = createBrickGeometry(currentBrickType.w, currentBrickType.h, currentBrickType.type);
            ghostBrick.traverse(child => {
                if (child.isMesh) {
                    child.material = child.material.clone();
                    child.material.transparent = true;
                    child.material.opacity = 0.5;
                    child.material.color.setHex(COLORS[currentColor]);
                }
            });
            ghostBrick.rotation.y = currentRotation;
            scene.add(ghostBrick);
        }

        function createBaseplate() {
            if (baseplate) {
                scene.remove(baseplate);
            }

            const size = baseplateSize * STUD_UNIT;
            const geometry = new THREE.BoxGeometry(size, 0.16, size);
            const material = new THREE.MeshStandardMaterial({
                color: 0x4CAF50,
                roughness: 0.6,
                metalness: 0.1
            });
            baseplate = new THREE.Mesh(geometry, material);
            baseplate.receiveShadow = true;
            baseplate.position.y = -0.08;
            scene.add(baseplate);

            // Grid
            const gridHelper = new THREE.GridHelper(size, baseplateSize, 0x000000, 0x888888);
            gridHelper.position.y = 0.01;
            baseplate.add(gridHelper);
        }

        // ===== PLACEMENT & COLLISION =====
        function snapToGrid(x, z) {
            if (!gridSnap) return { x, z };
            return {
                x: Math.round(x / STUD_UNIT) * STUD_UNIT,
                z: Math.round(z / STUD_UNIT) * STUD_UNIT
            };
        }

        function getLayerHeight(layer) {
            return layer * BRICK_HEIGHT;
        }

        function checkCollision(x, y, z, width, depth, rotation, excludeBrick = null) {
            const halfW = width * STUD_UNIT / 2;
            const halfD = depth * STUD_UNIT / 2;

            for (let brick of placedBricks) {
                if (brick === excludeBrick) continue;

                const bx = brick.position.x;
                const by = brick.position.y;
                const bz = brick.position.z;
                const bw = brick.userData.width * STUD_UNIT / 2;
                const bd = brick.userData.depth * STUD_UNIT / 2;

                // Simple AABB collision (doesn't account for rotation perfectly, but good enough)
                const xOverlap = Math.abs(x - bx) < (halfW + bw);
                const yOverlap = Math.abs(y - by) < (BRICK_HEIGHT / 2 + BRICK_HEIGHT / 2);
                const zOverlap = Math.abs(z - bz) < (halfD + bd);

                if (xOverlap && yOverlap && zOverlap) {
                    return true;
                }
            }

            return false;
        }

        function findHighestBrickAt(x, z, width, depth) {
            let highest = 0;
            const halfW = width * STUD_UNIT / 2;
            const halfD = depth * STUD_UNIT / 2;

            for (let brick of placedBricks) {
                const bx = brick.position.x;
                const bz = brick.position.z;
                const bw = brick.userData.width * STUD_UNIT / 2;
                const bd = brick.userData.depth * STUD_UNIT / 2;

                const xOverlap = Math.abs(x - bx) < (halfW + bw - 0.1);
                const zOverlap = Math.abs(z - bz) < (halfD + bd - 0.1);

                if (xOverlap && zOverlap) {
                    const brickTop = brick.position.y + (brick.userData.brickType === 'plate' ? PLATE_HEIGHT / 2 : BRICK_HEIGHT / 2);
                    highest = Math.max(highest, brickTop);
                }
            }

            return highest;
        }

        function placeBrick(x, y, z) {
            const width = currentBrickType.w;
            const depth = currentBrickType.h;
            const brickType = currentBrickType.type;

            const snapped = snapToGrid(x, z);
            const baseY = findHighestBrickAt(snapped.x, snapped.z, width, depth);
            const finalY = baseY + (brickType === 'plate' ? PLATE_HEIGHT / 2 : BRICK_HEIGHT / 2);

            if (checkCollision(snapped.x, finalY, snapped.z, width, depth, currentRotation)) {
                return null;
            }

            const brick = createBrickGeometry(width, depth, brickType);
            brick.position.set(snapped.x, finalY, snapped.z);
            brick.rotation.y = angleSnap ? currentRotation : ghostBrick.rotation.y;

            brick.traverse(child => {
                if (child.isMesh) {
                    child.material = child.material.clone();
                    child.material.color.setHex(COLORS[currentColor]);
                }
            });

            brick.userData = {
                width: width,
                depth: depth,
                brickType: brickType,
                color: currentColor,
                rotation: brick.rotation.y
            };

            scene.add(brick);
            placedBricks.push(brick);

            // Animation
            const startY = finalY + 5;
            brick.position.y = startY;
            animateBrickDrop(brick, startY, finalY);

            // Sound
            playPlacementSound();

            // Haptic
            if (navigator.vibrate) {
                navigator.vibrate(10);
            }

            // Undo stack
            pushUndo({ type: 'add', brick: brick });

            return brick;
        }

        function animateBrickDrop(brick, startY, endY) {
            const duration = 300;
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);

                brick.position.y = startY + (endY - startY) * eased;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Wobble effect
                    brick.rotation.z = 0.05;
                    setTimeout(() => {
                        brick.rotation.z = -0.03;
                        setTimeout(() => {
                            brick.rotation.z = 0;
                        }, 50);
                    }, 50);
                }
            }

            animate();
        }

        // ===== SELECTION =====
        function selectBrick(brick, multi = false) {
            if (!multi) {
                clearSelection();
            }

            if (!selectedBricks.includes(brick)) {
                selectedBricks.push(brick);
                brick.traverse(child => {
                    if (child.isMesh) {
                        child.material.emissive.setHex(0x4444ff);
                        child.material.emissiveIntensity = 0.3;
                    }
                });
            }

            updateSelectionInfo();
        }

        function deselectBrick(brick) {
            const index = selectedBricks.indexOf(brick);
            if (index > -1) {
                selectedBricks.splice(index, 1);
                brick.traverse(child => {
                    if (child.isMesh) {
                        child.material.emissive.setHex(0x000000);
                        child.material.emissiveIntensity = 0;
                    }
                });
            }

            updateSelectionInfo();
        }

        function clearSelection() {
            for (let brick of selectedBricks) {
                brick.traverse(child => {
                    if (child.isMesh) {
                        child.material.emissive.setHex(0x000000);
                        child.material.emissiveIntensity = 0;
                    }
                });
            }
            selectedBricks = [];
            updateSelectionInfo();
        }

        function updateSelectionInfo() {
            const info = document.getElementById('selection-info');
            if (selectedBricks.length > 0) {
                info.textContent = `${selectedBricks.length} brick${selectedBricks.length > 1 ? 's' : ''} selected`;
                info.classList.add('visible');
            } else {
                info.classList.remove('visible');
            }
        }

        function deleteSelected() {
            if (selectedBricks.length === 0) return;

            pushUndo({ type: 'delete', bricks: [...selectedBricks] });

            for (let brick of selectedBricks) {
                createDeleteParticles(brick.position);
                scene.remove(brick);
                const index = placedBricks.indexOf(brick);
                if (index > -1) {
                    placedBricks.splice(index, 1);
                }
            }

            selectedBricks = [];
            updateSelectionInfo();

            if (navigator.vibrate) {
                navigator.vibrate([20, 10, 20]);
            }
        }

        function createDeleteParticles(position) {
            const particleCount = 20;
            const particles = [];

            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: Math.random() * 0xffffff,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    Math.random() * 5,
                    (Math.random() - 0.5) * 5
                );

                particle.userData.velocity = velocity;
                scene.add(particle);
                particles.push(particle);
            }

            const startTime = Date.now();
            const duration = 1000;

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;

                if (progress < 1) {
                    for (let particle of particles) {
                        particle.userData.velocity.y -= 0.3;
                        particle.position.add(particle.userData.velocity.clone().multiplyScalar(0.05));
                        particle.material.opacity = 1 - progress;
                        particle.rotation.x += 0.1;
                        particle.rotation.y += 0.1;
                    }
                    requestAnimationFrame(animate);
                } else {
                    for (let particle of particles) {
                        scene.remove(particle);
                    }
                }
            }

            animate();
        }

        // ===== UNDO/REDO =====
        function pushUndo(action) {
            undoStack.push(action);
            redoStack = [];
            updateUndoRedoButtons();
        }

        function undo() {
            if (undoStack.length === 0) return;

            const action = undoStack.pop();
            redoStack.push(action);

            if (action.type === 'add') {
                scene.remove(action.brick);
                const index = placedBricks.indexOf(action.brick);
                if (index > -1) {
                    placedBricks.splice(index, 1);
                }
            } else if (action.type === 'delete') {
                for (let brick of action.bricks) {
                    scene.add(brick);
                    placedBricks.push(brick);
                }
            }

            updateUndoRedoButtons();
        }

        function redo() {
            if (redoStack.length === 0) return;

            const action = redoStack.pop();
            undoStack.push(action);

            if (action.type === 'add') {
                scene.add(action.brick);
                placedBricks.push(action.brick);
            } else if (action.type === 'delete') {
                for (let brick of action.bricks) {
                    scene.remove(brick);
                    const index = placedBricks.indexOf(brick);
                    if (index > -1) {
                        placedBricks.splice(index, 1);
                    }
                }
            }

            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            document.getElementById('btn-undo').disabled = undoStack.length === 0;
            document.getElementById('btn-redo').disabled = redoStack.length === 0;
        }

        // ===== COPY/PASTE =====
        function copySelected() {
            if (selectedBricks.length === 0) return;

            copiedBricks = selectedBricks.map(brick => ({
                width: brick.userData.width,
                depth: brick.userData.depth,
                brickType: brick.userData.brickType,
                color: brick.userData.color,
                rotation: brick.userData.rotation,
                relativePos: brick.position.clone()
            }));

            // Calculate center
            const center = new THREE.Vector3();
            for (let brick of selectedBricks) {
                center.add(brick.position);
            }
            center.divideScalar(selectedBricks.length);

            // Make positions relative to center
            for (let i = 0; i < copiedBricks.length; i++) {
                copiedBricks[i].relativePos.sub(center);
            }
        }

        function pasteSelected() {
            if (copiedBricks.length === 0) return;

            clearSelection();

            const pasteCenter = ghostBrick.position.clone();

            for (let data of copiedBricks) {
                const pos = pasteCenter.clone().add(data.relativePos);

                const brick = createBrickGeometry(data.width, data.depth, data.brickType);
                brick.position.copy(pos);
                brick.rotation.y = data.rotation;

                brick.traverse(child => {
                    if (child.isMesh) {
                        child.material = child.material.clone();
                        child.material.color.setHex(COLORS[data.color]);
                    }
                });

                brick.userData = {
                    width: data.width,
                    depth: data.depth,
                    brickType: data.brickType,
                    color: data.color,
                    rotation: data.rotation
                };

                scene.add(brick);
                placedBricks.push(brick);
                selectBrick(brick, true);
            }

            pushUndo({ type: 'paste', bricks: [...selectedBricks] });
            playPlacementSound();
        }

        // ===== SAVE/LOAD =====
        function saveProject() {
            const data = {
                bricks: placedBricks.map(brick => ({
                    width: brick.userData.width,
                    depth: brick.userData.depth,
                    brickType: brick.userData.brickType,
                    color: brick.userData.color,
                    position: brick.position.toArray(),
                    rotation: brick.rotation.y
                })),
                baseplateSize: baseplateSize,
                timestamp: Date.now()
            };

            localStorage.setItem('brickforge_project', JSON.stringify(data));

            // Generate thumbnail
            generateThumbnail().then(thumbnail => {
                localStorage.setItem('brickforge_thumbnail', thumbnail);
            });

            alert('Project saved successfully!');
        }

        function loadProject() {
            const data = localStorage.getItem('brickforge_project');
            if (!data) {
                alert('No saved project found!');
                return;
            }

            clearScene();

            const project = JSON.parse(data);

            if (project.baseplateSize) {
                baseplateSize = project.baseplateSize;
                document.getElementById('baseplate-size').value = baseplateSize;
                createBaseplate();
            }

            for (let brickData of project.bricks) {
                const brick = createBrickGeometry(brickData.width, brickData.depth, brickData.brickType);
                brick.position.fromArray(brickData.position);
                brick.rotation.y = brickData.rotation;

                brick.traverse(child => {
                    if (child.isMesh) {
                        child.material = child.material.clone();
                        child.material.color.setHex(COLORS[brickData.color]);
                    }
                });

                brick.userData = {
                    width: brickData.width,
                    depth: brickData.depth,
                    brickType: brickData.brickType,
                    color: brickData.color,
                    rotation: brickData.rotation
                };

                scene.add(brick);
                placedBricks.push(brick);
            }

            alert('Project loaded successfully!');
        }

        function loadFromLocalStorage() {
            const data = localStorage.getItem('brickforge_project');
            if (data) {
                const project = JSON.parse(data);
                if (project.baseplateSize) {
                    baseplateSize = project.baseplateSize;
                    document.getElementById('baseplate-size').value = baseplateSize;
                    createBaseplate();
                }
            }
        }

        function exportJSON() {
            const data = {
                bricks: placedBricks.map(brick => ({
                    width: brick.userData.width,
                    depth: brick.userData.depth,
                    brickType: brick.userData.brickType,
                    color: brick.userData.color,
                    position: brick.position.toArray(),
                    rotation: brick.rotation.y
                })),
                baseplateSize: baseplateSize
            };

            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `brickforge_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importJSON() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        clearScene();

                        if (data.baseplateSize) {
                            baseplateSize = data.baseplateSize;
                            document.getElementById('baseplate-size').value = baseplateSize;
                            createBaseplate();
                        }

                        for (let brickData of data.bricks) {
                            const brick = createBrickGeometry(brickData.width, brickData.depth, brickData.brickType);
                            brick.position.fromArray(brickData.position);
                            brick.rotation.y = brickData.rotation;

                            brick.traverse(child => {
                                if (child.isMesh) {
                                    child.material = child.material.clone();
                                    child.material.color.setHex(COLORS[brickData.color]);
                                }
                            });

                            brick.userData = {
                                width: brickData.width,
                                depth: brickData.depth,
                                brickType: brickData.brickType,
                                color: brickData.color,
                                rotation: brickData.rotation
                            };

                            scene.add(brick);
                            placedBricks.push(brick);
                        }

                        alert('Project imported successfully!');
                    } catch (error) {
                        alert('Error importing project: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function generateThumbnail() {
            return new Promise((resolve) => {
                renderer.render(scene, camera);
                const thumbnail = renderer.domElement.toDataURL('image/png', 0.5);
                resolve(thumbnail);
            });
        }

        function clearScene() {
            for (let brick of placedBricks) {
                scene.remove(brick);
            }
            placedBricks = [];
            selectedBricks = [];
            undoStack = [];
            redoStack = [];
            updateUndoRedoButtons();
            updateSelectionInfo();
        }

        // ===== TEMPLATES =====
        function loadTemplate(name) {
            if (!TEMPLATES[name]) return;

            clearScene();

            const template = TEMPLATES[name];
            for (let brickData of template) {
                const brickType = BRICK_TYPES.find(t =>
                    t.type === brickData.type &&
                    t.w === brickData.w &&
                    t.h === brickData.h
                );

                if (!brickType) continue;

                const brick = createBrickGeometry(brickData.w, brickData.h, brickData.type);

                const height = brickData.type === 'plate' ? PLATE_HEIGHT : BRICK_HEIGHT;
                brick.position.set(
                    brickData.x * STUD_UNIT,
                    brickData.y * BRICK_HEIGHT + height / 2,
                    brickData.z * STUD_UNIT
                );

                brick.rotation.y = brickData.rotation * Math.PI / 2;

                brick.traverse(child => {
                    if (child.isMesh) {
                        child.material = child.material.clone();
                        child.material.color.setHex(COLORS[brickData.color]);
                    }
                });

                brick.userData = {
                    width: brickData.w,
                    depth: brickData.h,
                    brickType: brickData.type,
                    color: brickData.color,
                    rotation: brick.rotation.y
                };

                scene.add(brick);
                placedBricks.push(brick);
            }

            playPlacementSound();
        }

        // ===== AUDIO =====
        function playPlacementSound() {
            if (!audioContext) return;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = 800;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // ===== EVENT HANDLERS =====
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Update ghost brick position
            const intersects = raycaster.intersectObject(baseplate);
            if (intersects.length > 0 && ghostBrick) {
                const point = intersects[0].point;
                const snapped = snapToGrid(point.x, point.z);
                const baseY = findHighestBrickAt(snapped.x, snapped.z, currentBrickType.w, currentBrickType.h);
                const height = currentBrickType.type === 'plate' ? PLATE_HEIGHT : BRICK_HEIGHT;
                ghostBrick.position.set(snapped.x, baseY + height / 2, snapped.z);

                // Check collision for visual feedback
                const collision = checkCollision(
                    snapped.x,
                    baseY + height / 2,
                    snapped.z,
                    currentBrickType.w,
                    currentBrickType.h,
                    currentRotation
                );

                ghostBrick.traverse(child => {
                    if (child.isMesh) {
                        child.material.opacity = collision ? 0.3 : 0.5;
                    }
                });
            }
        }

        function onClick(event) {
            if (isSelecting) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check if clicking on a brick
            const brickIntersects = raycaster.intersectObjects(placedBricks, true);
            if (brickIntersects.length > 0) {
                let brick = brickIntersects[0].object;
                while (brick.parent && !brick.userData.width) {
                    brick = brick.parent;
                }

                if (event.ctrlKey || event.metaKey) {
                    // Recolor
                    brick.traverse(child => {
                        if (child.isMesh) {
                            child.material.color.setHex(COLORS[currentColor]);
                        }
                    });
                    brick.userData.color = currentColor;
                } else if (event.shiftKey) {
                    // Multi-select
                    if (selectedBricks.includes(brick)) {
                        deselectBrick(brick);
                    } else {
                        selectBrick(brick, true);
                    }
                } else {
                    // Single select
                    selectBrick(brick);
                }
                return;
            }

            // Place brick
            const baseIntersects = raycaster.intersectObject(baseplate);
            if (baseIntersects.length > 0 && !event.shiftKey) {
                const point = baseIntersects[0].point;
                placeBrick(point.x, 0, point.z);
            }
        }

        let isDragging = false;
        let dragStart = null;

        function onMouseDown(event) {
            if (event.shiftKey && event.button === 0) {
                isSelecting = true;
                dragStart = { x: event.clientX, y: event.clientY };

                if (!selectionBox) {
                    selectionBox = document.createElement('div');
                    selectionBox.style.position = 'absolute';
                    selectionBox.style.border = '2px dashed #667eea';
                    selectionBox.style.background = 'rgba(102, 126, 234, 0.1)';
                    selectionBox.style.pointerEvents = 'none';
                    document.body.appendChild(selectionBox);
                }

                selectionBox.style.left = dragStart.x + 'px';
                selectionBox.style.top = dragStart.y + 'px';
                selectionBox.style.width = '0px';
                selectionBox.style.height = '0px';
                selectionBox.style.display = 'block';

                document.addEventListener('mousemove', onSelectionDrag);
                document.addEventListener('mouseup', onSelectionEnd);
            }
        }

        function onSelectionDrag(event) {
            if (!isSelecting) return;

            const width = event.clientX - dragStart.x;
            const height = event.clientY - dragStart.y;

            selectionBox.style.left = Math.min(dragStart.x, event.clientX) + 'px';
            selectionBox.style.top = Math.min(dragStart.y, event.clientY) + 'px';
            selectionBox.style.width = Math.abs(width) + 'px';
            selectionBox.style.height = Math.abs(height) + 'px';
        }

        function onSelectionEnd(event) {
            if (!isSelecting) return;

            isSelecting = false;
            selectionBox.style.display = 'none';

            document.removeEventListener('mousemove', onSelectionDrag);
            document.removeEventListener('mouseup', onSelectionEnd);

            // Find bricks in selection box
            const box = {
                left: Math.min(dragStart.x, event.clientX),
                right: Math.max(dragStart.x, event.clientX),
                top: Math.min(dragStart.y, event.clientY),
                bottom: Math.max(dragStart.y, event.clientY)
            };

            clearSelection();

            for (let brick of placedBricks) {
                const pos = brick.position.clone();
                pos.project(camera);

                const x = (pos.x + 1) / 2 * window.innerWidth;
                const y = -(pos.y - 1) / 2 * window.innerHeight;

                if (x >= box.left && x <= box.right && y >= box.top && y <= box.bottom) {
                    selectBrick(brick, true);
                }
            }
        }

        function onMouseUp(event) {
            isDragging = false;
        }

        function onContextMenu(event) {
            event.preventDefault();
        }

        function onKeyDown(event) {
            // Rotation
            if (event.key === 'q' || event.key === 'Q') {
                currentRotation -= Math.PI / 2;
                if (ghostBrick) {
                    ghostBrick.rotation.y = currentRotation;
                }
            } else if (event.key === 'e' || event.key === 'E') {
                currentRotation += Math.PI / 2;
                if (ghostBrick) {
                    ghostBrick.rotation.y = currentRotation;
                }
            }

            // Delete
            if (event.key === 'Delete' || event.key === 'Backspace') {
                deleteSelected();
            }

            // Undo/Redo
            if ((event.ctrlKey || event.metaKey) && event.key === 'z') {
                event.preventDefault();
                undo();
            } else if ((event.ctrlKey || event.metaKey) && event.key === 'y') {
                event.preventDefault();
                redo();
            }

            // Copy/Paste
            if ((event.ctrlKey || event.metaKey) && event.key === 'c') {
                event.preventDefault();
                copySelected();
            } else if ((event.ctrlKey || event.metaKey) && event.key === 'v') {
                event.preventDefault();
                pasteSelected();
            }
        }

        // Touch events
        let touchStart = null;

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                touchStart = { x: event.touches[0].clientX, y: event.touches[0].clientY };
            }
        }

        function onTouchMove(event) {
            if (event.touches.length === 1 && touchStart) {
                const touch = event.touches[0];
                const dx = touch.clientX - touchStart.x;
                const dy = touch.clientY - touchStart.y;

                if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
                    // Update ghost brick
                    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                    onMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
                }
            }
        }

        function onTouchEnd(event) {
            if (touchStart && event.changedTouches.length === 1) {
                const touch = event.changedTouches[0];
                const dx = touch.clientX - touchStart.x;
                const dy = touch.clientY - touchStart.y;

                if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
                    onClick({ clientX: touch.clientX, clientY: touch.clientY });
                }
            }
            touchStart = null;
        }

        // ===== UI INITIALIZATION =====
        function initUI() {
            // Brick palette
            const palette = document.getElementById('brick-palette');
            BRICK_TYPES.forEach((type, index) => {
                const item = document.createElement('div');
                item.className = 'brick-item';
                if (index === 0) item.classList.add('selected');
                item.textContent = type.name;
                item.addEventListener('click', () => {
                    document.querySelectorAll('.brick-item').forEach(el => el.classList.remove('selected'));
                    item.classList.add('selected');
                    currentBrickType = type;
                    createGhostBrick();
                });
                palette.appendChild(item);
            });

            // Color palette
            const colorPalette = document.getElementById('color-palette');
            Object.keys(COLORS).forEach((colorName, index) => {
                const item = document.createElement('div');
                item.className = 'color-item';
                if (index === 0) item.classList.add('selected');
                item.style.background = `#${COLORS[colorName].toString(16).padStart(6, '0')}`;
                item.title = colorName;
                item.addEventListener('click', () => {
                    document.querySelectorAll('.color-item').forEach(el => el.classList.remove('selected'));
                    item.classList.add('selected');
                    currentColor = colorName;
                    createGhostBrick();
                });
                colorPalette.appendChild(item);
            });

            // Template gallery
            const templateGallery = document.getElementById('template-gallery');
            Object.keys(TEMPLATES).forEach(name => {
                const item = document.createElement('div');
                item.className = 'template-item';
                item.textContent = name;
                item.addEventListener('click', () => {
                    loadTemplate(name);
                });
                templateGallery.appendChild(item);
            });

            // Button handlers
            document.getElementById('btn-undo').addEventListener('click', undo);
            document.getElementById('btn-redo').addEventListener('click', redo);
            document.getElementById('btn-copy').addEventListener('click', copySelected);
            document.getElementById('btn-paste').addEventListener('click', pasteSelected);
            document.getElementById('btn-delete').addEventListener('click', deleteSelected);
            document.getElementById('btn-save').addEventListener('click', saveProject);
            document.getElementById('btn-load').addEventListener('click', loadProject);
            document.getElementById('btn-export').addEventListener('click', exportJSON);
            document.getElementById('btn-import').addEventListener('click', importJSON);
            document.getElementById('btn-clear').addEventListener('click', () => {
                if (confirm('Clear entire scene? This cannot be undone.')) {
                    clearScene();
                }
            });

            // Toggle handlers
            document.getElementById('toggle-grid').addEventListener('click', function() {
                gridSnap = !gridSnap;
                this.classList.toggle('active');
            });

            document.getElementById('toggle-angle').addEventListener('click', function() {
                angleSnap = !angleSnap;
                this.classList.toggle('active');
            });

            // Baseplate size
            document.getElementById('baseplate-size').addEventListener('change', function() {
                baseplateSize = parseInt(this.value);
                createBaseplate();
            });

            // Panel toggle
            document.getElementById('toggle-panel').addEventListener('click', function() {
                const panel = document.getElementById('ui-panel');
                panel.classList.toggle('collapsed');
                this.classList.toggle('panel-open');
                this.textContent = panel.classList.contains('collapsed') ? '‚ò∞' : '‚úï';
            });

            updateUndoRedoButtons();
        }

        // ===== ANIMATION LOOP =====
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // ===== START =====
        init();
    </script>
</body>
</html>